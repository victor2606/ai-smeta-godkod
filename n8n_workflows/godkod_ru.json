{
  "nodes": [
    {
      "parameters": {
        "options": {
          "responseMode": "responseNodes"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.3,
      "position": [-80, 0],
      "id": "12e6b6e4-ecbf-4e3d-897d-433eb9fbd99b",
      "name": "When chat message received",
      "webhookId": "cbad68ab-68be-43c2-9699-3eca7df58da2"
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "=<Role>\nRoleName: Expert Cost Estimator with Database Access\nRoleDesc: You are a construction cost estimation expert with access to a database of 28,686 rates and 294,883 resources. You must learn PromptCode - a structured reasoning framework defined below. Follow the rules and execute reasoning logic code strictly as written in <Reasoning Logic>. Your goal is to help users find rates, calculate costs, and compare options using systematic analysis.\n</Role>\n\n<Search Strategy Guide>\nWhen to use which search tool:\n\n**Use natural_search (keyword-based) when:**\n✅ User mentions specific materials: \"ГКЛ\", \"бетон М300\", \"арматура А500\"\n✅ Query has exact technical terms: \"перегородки\", \"монолитный\", \"облицовка\"\n✅ User provides rate code or partial code: \"10-05-001\", \"ГЭСНп\"\n✅ Need fast, exact matching on known terminology\nExample: \"перегородки из гипсокартона 12.5мм\" → natural_search\n\n**Use vector_search (semantic) when:**\n✅ User describes work purpose: \"для утепления\", \"чтобы защитить от влаги\"\n✅ Query is conceptual: \"что нужно для ремонта фасада\"\n✅ Synonyms/related terms: \"теплоизоляция\" instead of specific material\n✅ natural_search returned poor/no results\n✅ User asks \"что подойдёт для...\", \"найди похожие\"\nExample: \"материалы для звукоизоляции межквартирных перегородок\" → vector_search\n\n**Use both (hybrid approach) when:**\n✅ Query mixes specific terms + conceptual description\n✅ Unclear if user wants exact match or alternatives\n✅ Initial search gives poor results - try the other method\nExample: \"недорогие материалы для утепления стен\" → try both, merge results\n\n**Fallback strategy:**\n1. Try primary search method first\n2. If results are poor (< 3 results or low relevance):\n   - Switch to alternative method\n   - Or ask clarifying question\n3. Never return \"не найдено\" without trying alternative approach\n</Search Strategy Guide>\n\n<PromptCode>\nPromptCode is a structured reasoning code that explicitly defines logical steps to solve estimation tasks. It is a hybrid of Python programming and natural language, designed specifically for LLM comprehension.\n\nKey principles:\n- Uses Python-like syntax for control flow (if, while, for, functions)\n- Combines code structure with natural language descriptions\n- All data MUST come from MCP tools - NEVER invent numbers\n- Enables programmatic reasoning within the model\n- Ensures systematic verification and self-correction\n</PromptCode>\n\n<Rule>\nPurpose of each module designed below:\n\n<MCP Tools Definition>: Learn the 6 available MCP tools and their parameters. Reference this when deciding which tool to use.\n\n<Search Strategy Guide>: Critical guide for choosing between natural_search (keyword-based) and vector_search (semantic/AI-powered) based on query type.\n\n<Unit Verification Module>: CRITICAL module for checking measurement units consistency. Always execute before calculations.\n\n<Reasoning Logic>: The most important part. You MUST reason through user requests following this logic line by line. This creates internal debate between Agent_A (optimistic estimator) and Agent_B (critical validator) to ensure accuracy.\n\n<Response Format>: Guidelines for structuring your final answer to the user.\n</Rule>\n\n<MCP Tools Definition>\nYou have access to 6 MCP tools for working with the construction rates database:\n\nTool 1: natural_search\nPurpose: Full-text search for construction rates by description in Russian (keyword-based)\nParameters:\n  - query (string, required): Search description (e.g., \"перегородки гипсокартон\")\n  - unit_type (string, optional): Filter by unit (e.g., \"м2\", \"м3\", \"т\")\n  - limit (integer, optional): Max results (default: 10, max: 100)\nReturns: List of matching rates with code, name, unit, cost per unit, rank score\nWhen to use: User asks \"найди расценку на...\" with specific keywords\nBest for: Exact keyword matches, specific material names, rate codes\n\nTool 2: vector_search\nPurpose: Semantic search for construction rates using meaning and context (AI-powered)\nParameters:\n  - query (string, required): Natural language description (e.g., \"утепление стен минеральной ватой\")\n  - limit (integer, optional): Max results (default: 10, max: 100)\n  - unit_type (string, optional): Filter by unit (e.g., \"м2\", \"м3\", \"т\")\n  - similarity_threshold (float, optional): Min similarity score 0-1 (default: 0.0, higher = stricter)\nReturns: List of matching rates with code, name, unit, cost per unit, similarity score, distance\nWhen to use: \n  - User describes work conceptually without exact keywords\n  - natural_search returns poor results\n  - Need to find rates by meaning/intent rather than exact words\n  - User asks \"что подойдёт для...\", \"найди похожие работы\"\nBest for: Conceptual queries, synonyms, related concepts, fuzzy descriptions\nIMPORTANT: Requires OPENAI_API_KEY to be set. If unavailable, falls back to natural_search.\n\nTool 3: quick_calculate\nPurpose: Fast cost calculation for a rate code or search query\nParameters:\n  - identifier (string, required): Rate code (e.g., \"10-05-001-01\") OR search query\n  - quantity (number, required): Work volume in rate's units\nReturns: Total cost, cost per unit, materials breakdown, resources breakdown\nWhen to use: User asks \"сколько будет стоить...\", needs cost for specific volume\nCRITICAL: Always verify units match between rate and user's quantity!\n\nTool 4: show_rate_details\nPurpose: Detailed resource breakdown for a rate\nParameters:\n  - rate_code (string, required): Rate code (e.g., \"10-05-001-01\")\n  - quantity (number, optional): Work volume (default: rate's base quantity)\nReturns: Full breakdown of all resources (materials, labor, equipment) with adjusted quantities and costs\nWhen to use: User asks for \"детализацию\", \"состав расценки\", \"что входит\"\n\nTool 5: compare_variants\nPurpose: Compare multiple rate options\nParameters:\n  - rate_codes (array of strings, required): List of rate codes to compare\n  - quantity (number, required): Work volume for comparison\nReturns: Comparison table with total costs, materials, difference from cheapest (₽ and %)\nWhen to use: User asks \"сравни варианты\", \"что дешевле\", wants to evaluate options\n\nTool 6: find_similar_rates\nPurpose: Find alternative rates similar to given rate\nParameters:\n  - rate_code (string, required): Reference rate code\n  - max_results (integer, optional): Max alternatives (default: 5)\nReturns: List of similar rates with cost comparison\nWhen to use: User asks \"найди альтернативы\", \"что еще подойдет\", \"есть ли дешевле\"\n</MCP Tools Definition>\n\n<Unit Verification Module>\nCRITICAL: Always execute this module before any calculations!\n\nfunction verify_units(rate_unit_type, user_quantity_description):\n    \"\"\"\n    Verifies that user's quantity matches rate's unit type\n    \n    Common unit types in database:\n    - \"100 м2\" = per 100 square meters\n    - \"1 м3\" = per 1 cubic meter  \n    - \"1000 шт\" = per 1000 pieces\n    - \"1 т\" = per 1 ton\n    - \"1 м2\" = per 1 square meter\n    - \"10 м2\" = per 10 square meters\n    \"\"\"\n    \n    # Extract base unit from rate (e.g., \"м2\" from \"100 м2\")\n    rate_base_unit = extract_base_unit(rate_unit_type)\n    \n    # Parse user's description to identify intended unit\n    user_unit = parse_user_unit(user_quantity_description)\n    \n    if rate_base_unit != user_unit:\n        return {\n            'compatible': False,\n            'error': f\"⚠️ НЕСОВМЕСТИМОСТЬ ЕДИНИЦ: Расценка измеряется в {rate_base_unit}, а вы указали {user_unit}\",\n            'suggestion': f\"Уточните объём в {rate_base_unit}\"\n        }\n    \n    # Check if user understands the multiplier\n    # Example: Rate is \"100 м2\", user says \"150 м2\" -> quantity should be 150, NOT 1.5\n    return {\n        'compatible': True,\n        'normalized_quantity': user_quantity,\n        'note': f\"Расценка дана на {rate_unit_type}, расчёт для {user_quantity} будет пропорциональным\"\n    }\n</Unit Verification Module>\n\n<Reasoning Logic>\n# Initialize virtual debate agents\nAgent_A = OptimisticEstimator(role=\"quick_responder\")\nAgent_B = CriticalValidator(role=\"accuracy_checker\")\n\n# Parse user request\nuser_request = get_user_input()\nrequest_type = classify_request(user_request)\n\n# Set debate parameters\nMaxRounds = 5\nCounter = 0\nagreement = False\nfinal_answer = None\n\nwhile not agreement and Counter < MaxRounds:\n    Counter += 1\n    \n    # Agent_A proposes initial approach\n    if request_type == \"SEARCH\":\n        # Decide between natural_search (keyword) vs vector_search (semantic)\n        has_specific_keywords = contains_specific_terms(user_request)  # e.g., \"ГКЛ\", \"бетон М300\"\n        is_conceptual_query = is_describing_work_type(user_request)   # e.g., \"утепление\", \"что нужно для...\"\n        \n        if has_specific_keywords and not is_conceptual_query:\n            # Use keyword-based search for specific terms\n            approach_A = Agent_A.propose({\n                'action': 'use natural_search',\n                'reasoning': 'Query contains specific keywords/materials - exact match preferred',\n                'extract_keywords': extract_keywords(user_request),\n                'confidence': 0.8\n            })\n        elif is_conceptual_query or user_request_is_vague():\n            # Use semantic search for conceptual/fuzzy queries\n            approach_A = Agent_A.propose({\n                'action': 'use vector_search',\n                'reasoning': 'Query is conceptual/semantic - need meaning-based search',\n                'query': user_request,\n                'similarity_threshold': 0.5,  # Moderate strictness\n                'confidence': 0.75\n            })\n        else:\n            # Hybrid approach: try both and merge results\n            approach_A = Agent_A.propose({\n                'action': 'use both natural_search and vector_search',\n                'reasoning': 'Ambiguous query - combine keyword and semantic results',\n                'confidence': 0.7\n            })\n    \n    elif request_type == \"CALCULATE\":\n        approach_A = Agent_A.propose({\n            'action': 'use quick_calculate',\n            'reasoning': 'User wants cost calculation',\n            'extract_identifier': extract_identifier(user_request),\n            'extract_quantity': extract_quantity(user_request),\n            'confidence': 0.7\n        })\n    \n    elif request_type == \"COMPARE\":\n        approach_A = Agent_A.propose({\n            'action': 'use compare_variants',\n            'reasoning': 'User wants to compare options',\n            'extract_variants': extract_variants(user_request),\n            'confidence': 0.85\n        })\n    \n    elif request_type == \"DETAIL\":\n        approach_A = Agent_A.propose({\n            'action': 'use show_rate_details',\n            'reasoning': 'User wants detailed breakdown',\n            'extract_rate_code': extract_rate_code(user_request),\n            'confidence': 0.9\n        })\n    \n    elif request_type == \"ALTERNATIVES\":\n        approach_A = Agent_A.propose({\n            'action': 'use find_similar_rates',\n            'reasoning': 'User wants alternative options',\n            'extract_reference_rate': extract_reference_rate(user_request),\n            'confidence': 0.75\n        })\n    \n    else:  # AMBIGUOUS\n        approach_A = Agent_A.propose({\n            'action': 'ask_clarification',\n            'reasoning': 'Request is ambiguous, need more information',\n            'missing_info': identify_missing_info(user_request),\n            'confidence': 0.5\n        })\n    \n    # Agent_B critiques the approach\n    critique_B = Agent_B.critique(approach_A, checks=[\n        'are_all_parameters_available',\n        'is_unit_verification_needed',\n        'is_tool_selection_optimal',\n        'are_assumptions_documented',\n        'will_response_be_complete'\n    ])\n    \n    # Agent_A responds to critique\n    if critique_B.has_issues():\n        rebuttal_A = Agent_A.rebut(critique_B, {\n            'address_concerns': True,\n            'adjust_approach': True,\n            'add_verification_steps': True\n        })\n    else:\n        rebuttal_A = approach_A  # No changes needed\n    \n    # Agent_B validates the adjusted approach\n    validation_B = Agent_B.validate(rebuttal_A)\n    \n    if validation_B.approved:\n        agreement = True\n        final_answer = rebuttal_A\n    else:\n        # Continue debate with Agent_B's alternative suggestion\n        approach_A = validation_B.alternative_approach\n\n# Execute the agreed approach\nif final_answer.action == 'ask_clarification':\n    output_clarification_request(final_answer.missing_info)\nelse:\n    # CRITICAL: Execute unit verification before tool calls\n    if final_answer.requires_calculation:\n        unit_check = verify_units(\n            rate_unit_type=final_answer.rate_unit,\n            user_quantity_description=final_answer.user_quantity\n        )\n        \n        if not unit_check.compatible:\n            output_unit_error(unit_check.error, unit_check.suggestion)\n            exit()\n    \n    # Execute MCP tool call\n    result = execute_mcp_tool(\n        tool_name=final_answer.tool_name,\n        parameters=final_answer.parameters\n    )\n    \n    # Verify result validity\n    if result.is_empty() or result.has_errors():\n        output_error_message(result.error_details)\n    else:\n        # Format and output response\n        formatted_response = format_response(\n            result=result,\n            user_request=user_request,\n            calculation_details=final_answer.calculation_details\n        )\n        output(formatted_response)\n</Reasoning Logic>\n\n<Response Format>\nStructure your response following this template:\n\n## 1. Краткий ответ (Direct Answer)\n[1-2 sentences with the main result, always include numbers and units]\n\n## 2. Детальный расчёт (Detailed Calculation)\n**Расценка:** [rate_code]\n**Название:** [rate_full_name]\n**Объём работ:** [quantity] [unit]\n\n**ИТОГО: [total_cost] руб.**\n\nИз них:\n- Материалы: [materials_cost] руб. ([materials_percent]%)\n- Работа + техника: [resources_cost] руб. ([resources_percent]%)\n\n**Как рассчитано:**\n[Show calculation formula step-by-step]\n\n## 3. Источник данных (Data Source)\n[Explain which tool was used and why the result is reliable]\n\n## 4. Альтернативы (Alternatives) [if applicable]\n[Show 2-3 alternative options with price comparison]\n\n## 5. Примечания (Notes) [if applicable]\n[Important warnings, unit clarifications, or recommendations]\n\nFormatting rules:\n- Use tables for comparisons (markdown format)\n- Use ⚠️ for warnings, ✅ for recommendations, ❌ for errors\n- Always show source: rate codes, tool names\n- Round money to 2 decimals: 123,456.78 руб.\n- Use bold for emphasis: **ИТОГО: X руб.**\n</Response Format>\n\n<Critical Rules>\n1. NEVER INVENT DATA\n   ❌ WRONG: \"Стоимость примерно 200,000 руб.\" (made up number!)\n   ✅ RIGHT: Use MCP tool → get actual data → cite source\n\n2. ALWAYS VERIFY UNITS\n   - Before any calculation, execute <Unit Verification Module>\n   - If units don't match → stop and ask user to clarify\n   - Document unit conversion in response\n\n3. ALWAYS EXPLAIN CALCULATIONS\n   ❌ WRONG: \"Стоимость: 207,480 руб.\" (no explanation)\n   ✅ RIGHT: \"Базовая стоимость 138,320 руб. на 100 м² → 1,383.20 руб./м² → для 150 м²: 1,383.20 × 150 = 207,480 руб.\"\n\n4. WHEN AMBIGUOUS → ASK\n   If user request lacks:\n   - Material type → ask\n   - Quantity → ask\n   - Unit of measurement → ask\n   \n   Provide examples to help user clarify\n\n5. PRIORITIZE ACCURACY OVER SPEED\n   - Better to ask 2 clarifying questions than give wrong answer\n   - Use internal debate (Agent_A vs Agent_B) to catch errors\n   - Verify each step before proceeding\n\n6. CITE YOUR SOURCES\n   Always mention:\n   - Which MCP tool was used\n   - Rate code (if applicable)\n   - Any assumptions made\n</Critical Rules>\n\n<Example Reasoning Process>\n\nExample 1: Specific keywords (use natural_search)\nUser: \"Сколько будет стоить 150 м² перегородок из ГКЛ?\"\n\nInternal reasoning (following <Reasoning Logic>):\n\nRound 1:\n- Agent_A: \"Use quick_calculate with identifier='перегородки ГКЛ', quantity=150\"\n- Agent_B: \"⚠️ Problem: 'перегородки ГКЛ' is not a rate code. Should we search first?\"\n- Agent_A: \"Good point. 'ГКЛ' is specific keyword. Let's use natural_search first to find rate code, then calculate\"\n- Agent_B: \"✅ Approved. Also verify that user's 150 м² matches rate's unit\"\n\nRound 2:\n- Agent_A: \"Execute: natural_search('перегородки гипсокартон один слой', unit_type='м2', limit=5)\"\n- Agent_B: \"After search, pick most relevant rate (rank closest to 0)\"\n- Agent_A: \"Then verify_units() before quick_calculate()\"\n- Agent_B: \"✅ Agreed. This ensures accuracy\"\n\nagreement = True → Execute plan\n\nActual execution:\n1. Call natural_search → Get rate \"10-05-001-01\"\n2. Check units: rate is \"100 м2\", user wants \"150 м2\" → compatible ✓\n3. Call quick_calculate(\"10-05-001-01\", 150) → Get result\n4. Format response with all details\n5. Suggest alternatives using find_similar_rates\n\nExample 2: Conceptual query (use vector_search)\nUser: \"Что подойдёт для теплоизоляции внешних стен многоэтажки?\"\n\nInternal reasoning:\n\nRound 1:\n- Agent_A: \"This is conceptual - user describes purpose (теплоизоляция) not specific material\"\n- Agent_A: \"Use vector_search to find semantically similar rates\"\n- Agent_B: \"✅ Good choice. 'теплоизоляция внешних стен' is conceptual, not exact keywords\"\n- Agent_A: \"Set similarity_threshold=0.6 for decent quality matches\"\n\nRound 2:\n- Agent_A: \"Execute: vector_search('теплоизоляция внешних стен многоэтажного здания', limit=10, similarity_threshold=0.6)\"\n- Agent_B: \"After getting results, group by material type and show top options\"\n- Agent_A: \"Then compare_variants for top 3-5 options to help user choose\"\n- Agent_B: \"✅ This gives comprehensive answer with alternatives\"\n\nagreement = True → Execute plan\n\nActual execution:\n1. Call vector_search → Get 10 semantically similar rates\n2. Group by material: минвата, пенополистирол, пеностекло\n3. Pick top rate from each group\n4. Call compare_variants to show cost differences\n5. Format response with recommendations based on similarity scores\n\nExample 3: Hybrid approach (vague query)\nUser: \"Нужно что-то для стен в ванной\"\n\nInternal reasoning:\n\nRound 1:\n- Agent_A: \"Very vague - 'что-то для стен в ванной' could mean tiles, waterproofing, panels...\"\n- Agent_B: \"⚠️ Too ambiguous. We should ask clarifying question first\"\n- Agent_A: \"Or try hybrid: vector_search to understand intent + natural_search with keywords\"\n\nRound 2:\n- Agent_A: \"Actually, let's ask: 'Вы имеете в виду: 1) Облицовку плиткой 2) Гидроизоляцию 3) Штукатурку 4) Панели?'\"\n- Agent_B: \"✅ Better to clarify than guess wrong. Provide examples from database\"\n\nagreement = True → Ask clarification\n\nActual execution:\n1. Ask user to clarify intent with specific options\n2. Wait for user response\n3. Then use appropriate search tool based on clarified request\n</Example Reasoning Process>\n\n<Self-Check Before Response>\nBefore sending answer to user, verify:\n\n✅ All numbers come from MCP tools (not invented)?\n✅ Units are correct and explained?\n✅ Calculation steps are shown?\n✅ Source is cited (rate code, tool name)?\n✅ Response is structured (brief → details → alternatives)?\n✅ Formatting is used (tables, lists, emphasis)?\n✅ If ambiguous request → asked clarifying questions?\n✅ Any warnings or notes added where needed?\n\nIf any ✅ is unchecked → fix before responding!\n</Self-Check Before Response>",
          "returnIntermediateSteps": true,
          "enableStreaming": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [208, 0],
      "id": "0bac30fe-0e03-4590-a667-65c29398706e",
      "name": "AI Agent"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [256, 208],
      "id": "ecf6852f-e512-4e80-a004-a069f2b90db0",
      "name": "Simple Memory"
    },
    {
      "parameters": {
        "model": "anthropic/claude-sonnet-4",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [80, 208],
      "id": "18b76236-c8df-4881-89f9-c5c3c47ebbfd",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "tzR6urErAvGTaNkK",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "endpointUrl": "https://mcp-piplines.godkod.ru/mcp",
        "include": "selected",
        "includeTools": ["natural_search"],
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [400, 208],
      "id": "c90154a6-cdf6-4a43-9ed9-8972dd45e662",
      "name": "natural_search"
    },
    {
      "parameters": {
        "endpointUrl": "https://mcp-piplines.godkod.ru/mcp",
        "include": "selected",
        "includeTools": ["quick_calculate"],
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [528, 208],
      "id": "90fda17d-7692-49d0-836f-8b0097165508",
      "name": "quick_calculate"
    },
    {
      "parameters": {
        "endpointUrl": "https://mcp-piplines.godkod.ru/mcp",
        "include": "selected",
        "includeTools": ["show_rate_details"],
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [672, 208],
      "id": "5010e2a8-8b46-4726-ac4f-4d9a9458ff19",
      "name": "show_rate_details"
    },
    {
      "parameters": {
        "endpointUrl": "https://mcp-piplines.godkod.ru/mcp",
        "include": "selected",
        "includeTools": ["compare_variants"],
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [816, 208],
      "id": "bcb157e0-bf4f-407c-8a6d-e3925dd05066",
      "name": "compare_variants"
    },
    {
      "parameters": {
        "endpointUrl": "https://mcp-piplines.godkod.ru/mcp",
        "include": "selected",
        "includeTools": ["find_similar_rates"],
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [976, 208],
      "id": "551d97c0-ef3d-4838-abb9-e2349b6d3d46",
      "name": "find_similar_rates"
    },
    {
      "parameters": {
        "jsCode": "/**\n * РАСШИРЕННЫЕ УТИЛИТЫ - ИСПРАВЛЕННАЯ ВЕРСИЯ\n * для форматирования Reasoning в Telegram\n */\n\n// ═════════════════════════════════════════════════════════════════\n// 1. ФИЛЬТРЫ ДЛЯ ШАГОВ\n// ═════════════════════════════════════════════════════════════════\n\nfunction filterEmptySteps(steps) {\n  return steps.filter(step => {\n    try {\n      const obsText = step.observation?.[0]?.text || step.observation?.[0] || '{}';\n      const obs = JSON.parse(obsText);\n      return obs.success !== false && obs.count !== 0;\n    } catch {\n      return true;\n    }\n  });\n}\n\nfunction groupStepsByTool(steps) {\n  const groups = {};\n  steps.forEach(step => {\n    const tool = step.action.tool;\n    if (!groups[tool]) groups[tool] = [];\n    groups[tool].push(step);\n  });\n  return groups;\n}\n\nfunction getLastSuccessfulCalls(steps) {\n  const lastCalls = {};\n  steps.forEach(step => {\n    const tool = step.action.tool;\n    try {\n      const obsText = step.observation?.[0]?.text || step.observation?.[0] || '{}';\n      const obs = JSON.parse(obsText);\n      if (obs.success !== false && obs.count !== 0) {\n        lastCalls[tool] = step;\n      }\n    } catch {}\n  });\n  return Object.values(lastCalls);\n}\n\n// ═════════════════════════════════════════════════════════════════\n// 2. СТАТИСТИКА И АНАЛИТИКА\n// ═════════════════════════════════════════════════════════════════\n\nfunction collectStatistics(intermediateSteps) {\n  const stats = {\n    totalSteps: intermediateSteps.length,\n    successfulSteps: 0,\n    failedSteps: 0,\n    toolCounts: {},\n    totalTokens: 0,\n    avgTokensPerStep: 0,\n    totalDuration: 0\n  };\n\n  intermediateSteps.forEach(step => {\n    const tool = step.action.tool;\n    stats.toolCounts[tool] = (stats.toolCounts[tool] || 0) + 1;\n\n    const tokens = step.action.messageLog?.[0]?.kwargs?.response_metadata?.tokenUsage;\n    if (tokens) {\n      stats.totalTokens += tokens.totalTokens;\n    }\n\n    try {\n      const obsText = step.observation?.[0]?.text || step.observation?.[0] || '{}';\n      const obs = JSON.parse(obsText);\n      if (obs.success === false || obs.count === 0) {\n        stats.failedSteps++;\n      } else {\n        stats.successfulSteps++;\n      }\n    } catch {\n      stats.successfulSteps++;\n    }\n  });\n\n  if (stats.totalSteps > 0) {\n    stats.avgTokensPerStep = Math.round(stats.totalTokens / stats.totalSteps);\n  }\n\n  return stats;\n}\n\nfunction formatStatisticsWithoutTokens(stats) {\n  let msg = '📊 <b>СТАТИСТИКА ВЫПОЛНЕНИЯ</b>\\n\\n';\n  msg += `   • Всего шагов: ${stats.totalSteps}\\n`;\n  msg += `   • Успешных: ✅ ${stats.successfulSteps}\\n`;\n  msg += `   • Неудачных: ❌ ${stats.failedSteps}\\n\\n`;\n\n  msg += '<b>Использованные инструменты:</b>\\n';\n  Object.entries(stats.toolCounts).forEach(([tool, count]) => {\n    msg += `   • ${tool}: ${count}×\\n`;\n  });\n\n  return msg + '\\n';\n}\n\nfunction formatStatistics(stats) {\n  let msg = '📊 <b>СТАТИСТИКА ВЫПОЛНЕНИЯ</b>\\n\\n';\n  msg += `   • Всего шагов: ${stats.totalSteps}\\n`;\n  msg += `   • Успешных: ✅ ${stats.successfulSteps}\\n`;\n  msg += `   • Неудачных: ❌ ${stats.failedSteps}\\n`;\n  msg += `   • Всего токенов: ${stats.totalTokens.toLocaleString()}\\n`;\n  msg += `   • В среднем за шаг: ${stats.avgTokensPerStep.toLocaleString()}\\n\\n`;\n\n  msg += '<b>Использованные инструменты:</b>\\n';\n  Object.entries(stats.toolCounts).forEach(([tool, count]) => {\n    msg += `   • ${tool}: ${count}×\\n`;\n  });\n\n  return msg + '\\n';\n}\n\n// ═════════════════════════════════════════════════════════════════\n// 3. КАСТОМНЫЕ ЭМОДЗИ ДЛЯ ИНСТРУМЕНТОВ\n// ═════════════════════════════════════════════════════════════════\n\nconst TOOL_EMOJIS = {\n  'natural_search': '🔍',\n  'show_rate_details': '💰',\n  'compare_variants': '⚖️',\n  'quick_calculate': '🧮',\n  'web_search': '🌐',\n  'database_query': '🗄️',\n  'api_call': '🔌',\n  'file_read': '📄',\n  'calculate': '🧮',\n  'analyze': '📊',\n  'default': '🛠'\n};\n\nfunction getToolEmoji(toolName) {\n  return TOOL_EMOJIS[toolName] || TOOL_EMOJIS.default;\n}\n\n// ═════════════════════════════════════════════════════════════════\n// 4. ФОРМАТИРОВАНИЕ С ДОПОЛНИТЕЛЬНЫМИ ОПЦИЯМИ\n// ═════════════════════════════════════════════════════════════════\n\nfunction formatReasoningAdvanced(reasoningData, options = {}) {\n  const defaults = {\n    showTokens: false,\n    showEmptySteps: false,\n    showStatistics: true,\n    groupByTool: false,\n    compactMode: false,\n    maxSteps: null,\n    fullData: true, // New: controls whether to show full data or truncated\n    maxResults: null, // New: configurable max results to display (null = show all)\n    maxBreakdownItems: null // New: configurable max breakdown items (null = show all)\n  };\n\n  const opts = { ...defaults, ...options };\n\n  let steps = reasoningData.intermediateSteps || [];\n\n  if (!opts.showEmptySteps) {\n    steps = filterEmptySteps(steps);\n  }\n\n  if (opts.maxSteps && steps.length > opts.maxSteps) {\n    steps = steps.slice(0, opts.maxSteps);\n  }\n\n  let msg = '🤖 <b>REASONING TRACE</b>\\n━━━━━━━━━━━━━━━━━━━━\\n\\n';\n\n  const firstStep = reasoningData.intermediateSteps?.[0];\n  const model = firstStep?.action?.messageLog?.[0]?.kwargs?.response_metadata?.model_name;\n\n  if (model) {\n    msg += `📊 <b>Модель:</b> <code>${model}</code>\\n\\n`;\n  }\n\n  if (opts.showStatistics) {\n    const stats = collectStatistics(reasoningData.intermediateSteps);\n    msg += formatStatisticsWithoutTokens(stats);\n  }\n\n  if (opts.groupByTool) {\n    const groups = groupStepsByTool(steps);\n    Object.entries(groups).forEach(([tool, toolSteps]) => {\n      msg += `\\n${getToolEmoji(tool)} <b>${tool.toUpperCase()}</b> (${toolSteps.length})\\n`;\n      msg += '━━━━━━━━━━━━━━━━━━━━\\n\\n';\n      toolSteps.forEach((step, i) => {\n        msg += formatStep(step, i + 1, opts);\n      });\n    });\n  } else {\n    msg += '🔍 <b>ЦЕПОЧКА РАССУЖДЕНИЙ</b>\\n━━━━━━━━━━━━━━━━━━━━\\n\\n';\n    steps.forEach((step, i) => {\n      msg += formatStep(step, i + 1, opts);\n    });\n  }\n\n  msg += '\\n✅ <b>ИТОГОВЫЙ ОТВЕТ</b>\\n━━━━━━━━━━━━━━━━━━━━\\n\\n';\n  msg += convertMarkdownToTelegramHtml(reasoningData.output || '');\n\n  return msg;\n}\n\nfunction formatStep(step, stepNumber, opts) {\n  const { action, observation } = step;\n  let msg = '';\n\n  if (opts.compactMode) {\n    msg += `<b>${stepNumber}.</b> ${getToolEmoji(action.tool)} ${action.tool}`;\n\n    const params = Object.entries(action.toolInput || {})\n      .map(([k, v]) => `${k}=${JSON.stringify(v).substring(0, 30)}`)\n      .join(', ');\n    if (params) msg += ` (${params})`;\n\n    msg += ' → ';\n    msg += formatObservationShort(observation);\n    msg += '\\n';\n  } else {\n    msg += `<b>ШАГ ${stepNumber}</b> 🔸\\n`;\n\n    const thought = action.messageLog?.[0]?.kwargs?.content;\n    if (thought?.trim()) {\n      msg += `💭 <i>Рассуждение:</i> \"${thought}\"\\n\\n`;\n    }\n\n    msg += `${getToolEmoji(action.tool)} <b>Инструмент:</b> <code>${action.tool}</code>\\n`;\n\n    if (action.toolInput) {\n      msg += '📝 <b>Параметры запроса:</b>\\n';\n      Object.entries(action.toolInput).forEach(([key, value]) => {\n        const displayValue = typeof value === 'object' ? JSON.stringify(value) : value;\n        msg += `   • ${key}: <code>${displayValue}</code>\\n`;\n      });\n    }\n\n    msg += '\\n📦 <b>Ответ инструмента:</b>\\n';\n    msg += formatObservationFull(observation, opts); // Pass opts to formatObservationFull\n    msg += '\\n\\n━━━━━━━━━━━━━━━━━━━━\\n\\n';\n  }\n\n  return msg;\n}\n\nfunction formatObservationFull(observation, opts = {}) {\n  // Establish defaults for options that control truncation\n  const fullData = opts.fullData !== false; // Default to true (show full data)\n  const maxResults = opts.maxResults || null; // null = show all\n  const maxBreakdownItems = opts.maxBreakdownItems || null; // null = show all\n\n  try {\n    // Extract text from observation\n    let obsText = '';\n\n    if (Array.isArray(observation)) {\n      const firstObs = observation[0];\n      if (typeof firstObs === 'object' && firstObs.text) {\n        obsText = firstObs.text;\n      } else if (typeof firstObs === 'string') {\n        obsText = firstObs;\n      }\n    } else if (typeof observation === 'object' && observation.text) {\n      obsText = observation.text;\n    } else if (typeof observation === 'string') {\n      obsText = observation;\n    }\n\n    if (!obsText) {\n      return '   <i>Нет данных</i>\\n';\n    }\n\n    const obs = JSON.parse(obsText);\n    let msg = '';\n\n    if (obs.success === false) {\n      msg += '   ❌ <i>Запрос не выполнен</i>\\n';\n      if (obs.error) {\n        msg += `   <i>Ошибка: ${escapeHtml(obs.error)}</i>\\n`;\n      }\n      return msg;\n    }\n\n    if (obs.count === 0) {\n      msg += '   ⚠️ <i>Результаты не найдены (count: 0)</i>\\n';\n      return msg;\n    }\n\n    // Search results\n    if (obs.results && Array.isArray(obs.results)) {\n      msg += `   ✅ <b>Найдено записей: ${obs.count || obs.results.length}</b>\\n\\n`;\n\n      const resultsToShow = maxResults ? obs.results.slice(0, maxResults) : obs.results;\n      resultsToShow.forEach((result, idx) => {\n        msg += `   <b>${idx + 1}.</b> `;\n\n        if (result.rate_code) {\n          msg += `<code>${result.rate_code}</code>`;\n        }\n\n        if (result.rate_full_name) {\n          // Show full name without truncation when fullData is true\n          if (fullData) {\n            msg += ` - ${escapeHtml(result.rate_full_name)}`;\n          } else {\n            msg += ` - ${escapeHtml(result.rate_full_name.substring(0, 80))}`;\n            if (result.rate_full_name.length > 80) msg += '...';\n          }\n        }\n\n        if (result.unit_type) {\n          msg += ` (${escapeHtml(result.unit_type)})`;\n        }\n\n        if (result.cost_per_unit !== undefined) {\n          msg += `\\n      💰 ${result.cost_per_unit.toLocaleString()} руб./${escapeHtml(result.unit_type || 'ед')}`;\n        }\n\n        msg += '\\n';\n      });\n\n      if (maxResults && obs.results.length > maxResults) {\n        msg += `\\n   <i>... и ещё ${obs.results.length - maxResults} записей</i>\\n`;\n      }\n\n      return msg;\n    }\n\n    // Rate details (show_rate_details)\n    if (obs.rate_info && obs.total_cost !== undefined) {\n      msg += `   💰 <b>ИТОГО: ${obs.total_cost.toLocaleString()} руб.</b>\\n\\n`;\n      msg += `   📋 Расценка: <code>${obs.rate_info.rate_code}</code>\\n`;\n      msg += `   📝 ${escapeHtml(obs.rate_info.rate_full_name)}\\n`;\n      msg += `   📏 Цена за единицу: ${obs.cost_per_unit.toLocaleString()} руб./${escapeHtml(obs.rate_info.unit_type)}\\n`;\n      msg += `   📦 Объем: ${obs.quantity} ${escapeHtml(obs.rate_info.unit_type)}\\n\\n`;\n\n      if (obs.materials !== undefined && obs.resources !== undefined) {\n        msg += `   💵 Материалы: ${obs.materials.toLocaleString()} руб.\\n`;\n        msg += `   🔧 Работа + техника: ${obs.resources.toLocaleString()} руб.\\n\\n`;\n      }\n\n      if (obs.breakdown && obs.breakdown.length > 0) {\n        msg += '   <b>Состав работ:</b>\\n';\n        const breakdownToShow = maxBreakdownItems ? obs.breakdown.slice(0, maxBreakdownItems) : obs.breakdown;\n        breakdownToShow.forEach((item, idx) => {\n          msg += `      ${idx + 1}. ${escapeHtml(item.resource_name)}`;\n          if (item.adjusted_quantity) {\n            msg += ` (${item.adjusted_quantity} ${escapeHtml(item.unit)})`;\n          }\n          if (item.adjusted_cost) {\n            msg += ` - ${item.adjusted_cost.toLocaleString()} руб.`;\n          }\n          msg += '\\n';\n        });\n        if (maxBreakdownItems && obs.breakdown.length > maxBreakdownItems) {\n          msg += `      <i>... и ещё ${obs.breakdown.length - maxBreakdownItems} позиций</i>\\n`;\n        }\n      }\n\n      return msg;\n    }\n\n    // Quick calculate\n    if (obs.total_cost !== undefined && !obs.rate_info) {\n      msg += `   💰 <b>Стоимость: ${obs.total_cost.toLocaleString()} руб.</b>\\n`;\n      if (obs.rate_code) {\n        msg += `   📋 Расценка: <code>${obs.rate_code}</code>\\n`;\n      }\n      return msg;\n    }\n\n    // Compare variants\n    if (obs.comparison && Array.isArray(obs.comparison)) {\n      msg += `   ⚖️ <b>Сравнение ${obs.count} вариантов</b>\\n\\n`;\n\n      obs.comparison.forEach((variant, idx) => {\n        msg += `   <b>${idx + 1}. ${variant.rate_code}</b>\\n`;\n        msg += `      💰 За единицу: ${variant.cost_per_unit.toLocaleString()} руб./${escapeHtml(variant.unit_type)}\\n`;\n        msg += `      📦 За ${obs.quantity} ${escapeHtml(variant.unit_type)}: <b>${variant.total_for_quantity.toLocaleString()} руб.</b>\\n`;\n\n        if (variant.difference_from_cheapest > 0) {\n          msg += `      📈 Дороже на: +${variant.difference_from_cheapest.toLocaleString()} руб. (+${variant.difference_percent}%)\\n`;\n        } else if (idx === 0) {\n          msg += `      ✅ <i>Самый выгодный вариант</i>\\n`;\n        }\n\n        msg += '\\n';\n      });\n\n      return msg;\n    }\n\n    // Unknown structure - format JSON in human-readable way\n    if (Object.keys(obs).length > 0) {\n      msg += '   📋 <b>Данные получены:</b>\\n';\n      msg += formatUnknownJsonData(obs, fullData);\n      return msg;\n    }\n\n    return '   ℹ️ <i>Ответ получен</i>\\n';\n\n  } catch (e) {\n    // If parsing failed, show raw text in readable format\n    let obsText = '';\n\n    if (Array.isArray(observation)) {\n      const firstObs = observation[0];\n      obsText = (typeof firstObs === 'object' && firstObs.text) ? firstObs.text : String(firstObs || '');\n    } else if (typeof observation === 'object' && observation.text) {\n      obsText = observation.text;\n    } else {\n      obsText = String(observation || '');\n    }\n\n    if (!obsText) {\n      return '   <i>Нет данных</i>\\n';\n    }\n\n    // Format plain text response without HTML tags that could break\n    if (!fullData && obsText.length > 300) {\n      return '   ' + escapeHtml(obsText.substring(0, 300)) + '...\\n   <i>(обрезано - используйте fullData: true)</i>\\n';\n    } else {\n      return '   ' + escapeHtml(obsText) + '\\n';\n    }\n  }\n}\n\n/**\n * Formats unknown JSON data in a human-readable structured format\n * WITHOUT using <pre> tags that could break during message splitting\n */\nfunction formatUnknownJsonData(data, fullData = true) {\n  let msg = '';\n\n  // Remove technical fields that aren't useful for end users\n  const filteredData = { ...data };\n  delete filteredData.success;\n\n  const entries = Object.entries(filteredData);\n\n  // If empty after filtering, return early\n  if (entries.length === 0) {\n    return '   <i>Нет данных для отображения</i>\\n';\n  }\n\n  // Format each key-value pair on its own line with clear labels\n  entries.forEach(([key, value]) => {\n    const formattedKey = key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n\n    if (value === null || value === undefined) {\n      msg += `   • <b>${formattedKey}:</b> <i>не указано</i>\\n`;\n    } else if (Array.isArray(value)) {\n      msg += `   • <b>${formattedKey}:</b> [массив из ${value.length} элементов]\\n`;\n\n      // Show array items if reasonable size\n      if (value.length > 0 && value.length <= 5) {\n        value.forEach((item, idx) => {\n          if (typeof item === 'object') {\n            msg += `      ${idx + 1}. ${JSON.stringify(item)}\\n`;\n          } else {\n            msg += `      ${idx + 1}. ${escapeHtml(String(item))}\\n`;\n          }\n        });\n      } else if (value.length > 5 && fullData) {\n        // Show first 5 items\n        value.slice(0, 5).forEach((item, idx) => {\n          if (typeof item === 'object') {\n            msg += `      ${idx + 1}. ${JSON.stringify(item)}\\n`;\n          } else {\n            msg += `      ${idx + 1}. ${escapeHtml(String(item))}\\n`;\n          }\n        });\n        msg += `      <i>... и ещё ${value.length - 5} элементов</i>\\n`;\n      } else if (value.length > 5 && !fullData) {\n        msg += `      <i>используйте fullData: true для просмотра</i>\\n`;\n      }\n    } else if (typeof value === 'object') {\n      msg += `   • <b>${formattedKey}:</b>\\n`;\n\n      // Recursively format nested objects (limit depth to avoid overflow)\n      Object.entries(value).forEach(([nestedKey, nestedValue]) => {\n        const formattedNestedKey = nestedKey.replace(/_/g, ' ');\n\n        if (typeof nestedValue === 'object' && nestedValue !== null) {\n          msg += `      - ${formattedNestedKey}: ${JSON.stringify(nestedValue)}\\n`;\n        } else {\n          msg += `      - ${formattedNestedKey}: ${escapeHtml(String(nestedValue))}\\n`;\n        }\n      });\n    } else if (typeof value === 'boolean') {\n      msg += `   • <b>${formattedKey}:</b> ${value ? '✅ да' : '❌ нет'}\\n`;\n    } else if (typeof value === 'number') {\n      msg += `   • <b>${formattedKey}:</b> ${value.toLocaleString()}\\n`;\n    } else {\n      // String or other primitive type\n      const stringValue = String(value);\n\n      if (!fullData && stringValue.length > 100) {\n        msg += `   • <b>${formattedKey}:</b> ${escapeHtml(stringValue.substring(0, 100))}...\\n`;\n      } else {\n        msg += `   • <b>${formattedKey}:</b> ${escapeHtml(stringValue)}\\n`;\n      }\n    }\n  });\n\n  if (!fullData) {\n    msg += '\\n   <i>Используйте fullData: true для полного вывода</i>\\n';\n  }\n\n  return msg;\n}\n\nfunction formatObservationShort(observation) {\n  try {\n    let obsText = '';\n\n    if (Array.isArray(observation)) {\n      const firstObs = observation[0];\n      obsText = (typeof firstObs === 'object' && firstObs.text) ? firstObs.text : String(firstObs || '');\n    } else if (typeof observation === 'object' && observation.text) {\n      obsText = observation.text;\n    } else {\n      obsText = String(observation || '');\n    }\n\n    const obs = JSON.parse(obsText);\n\n    if (obs.success === false || obs.count === 0) return '❌ Не найдено';\n    if (obs.count > 0 || obs.results?.length) return `✅ Найдено: ${obs.count || obs.results.length}`;\n    if (obs.total_cost !== undefined) return `💰 ${obs.total_cost.toLocaleString()} руб.`;\n    if (obs.comparison) return `⚖️ ${obs.count} вариантов`;\n    return 'ℹ️ Данные получены';\n  } catch {\n    return 'ℹ️ Ответ получен';\n  }\n}\n\n// ═════════════════════════════════════════════════════════════════\n// 5. ЭКСПОРТ В РАЗНЫЕ ФОРМАТЫ\n// ═════════════════════════════════════════════════════════════════\n\nfunction exportToMarkdown(reasoningData) {\n  let md = '# Reasoning Trace\\n\\n';\n  md += `**Модель:** ${reasoningData.intermediateSteps?.[0]?.action?.messageLog?.[0]?.kwargs?.response_metadata?.model_name}\\n\\n`;\n\n  md += '## Шаги выполнения\\n\\n';\n  reasoningData.intermediateSteps?.forEach((step, i) => {\n    md += `### Шаг ${i + 1}: ${step.action.tool}\\n\\n`;\n    md += `**Параметры:**\\n\\`\\`\\`json\\n${JSON.stringify(step.action.toolInput, null, 2)}\\n\\`\\`\\`\\n\\n`;\n\n    let obsText = '';\n    if (Array.isArray(step.observation)) {\n      const firstObs = step.observation[0];\n      obsText = (typeof firstObs === 'object' && firstObs.text) ? firstObs.text : String(firstObs || '');\n    } else {\n      obsText = String(step.observation || '');\n    }\n\n    md += `**Результат:**\\n\\`\\`\\`json\\n${obsText}\\n\\`\\`\\`\\n\\n`;\n  });\n\n  md += '## Итоговый ответ\\n\\n';\n  md += reasoningData.output || '';\n\n  return md;\n}\n\nfunction exportToJSON(reasoningData) {\n  return JSON.stringify({\n    model: reasoningData.intermediateSteps?.[0]?.action?.messageLog?.[0]?.kwargs?.response_metadata?.model_name,\n    timestamp: new Date().toISOString(),\n    statistics: collectStatistics(reasoningData.intermediateSteps),\n    steps: reasoningData.intermediateSteps?.map((step, i) => ({\n      stepNumber: i + 1,\n      tool: step.action.tool,\n      input: step.action.toolInput,\n      output: step.observation,\n      tokens: step.action.messageLog?.[0]?.kwargs?.response_metadata?.tokenUsage\n    })),\n    finalAnswer: reasoningData.output\n  }, null, 2);\n}\n\n// ═════════════════════════════════════════════════════════════════\n// 6. ИНТЕГРАЦИЯ С N8N\n// ═════════════════════════════════════════════════════════════════\n\nfunction mainAdvanced() {\n  const inputData = $input.all();\n\n  if (!inputData || inputData.length === 0) {\n    return { json: { error: 'Нет входных данных' } };\n  }\n\n  const reasoningData = inputData[0].json;\n\n  // Enhanced default options with new parameters\n  const options = {\n    showTokens: false,\n    showEmptySteps: false,\n    showStatistics: true,\n    groupByTool: false,\n    compactMode: false,\n    maxSteps: null,\n    fullData: true, // Show all data without truncation by default\n    maxResults: null, // Show all search results by default (null = unlimited)\n    maxBreakdownItems: null // Show all breakdown items by default (null = unlimited)\n  };\n\n  const formattedMessage = formatReasoningAdvanced(reasoningData, options);\n  const messageParts = splitMessageForTelegram(formattedMessage);\n\n  const markdown = exportToMarkdown(reasoningData);\n  const jsonData = exportToJSON(reasoningData);\n\n  return messageParts.map((part, index) => ({\n    json: {\n      message: part,\n      part: index + 1,\n      total_parts: messageParts.length,\n      parse_mode: 'HTML',\n      extras: {\n        markdown: index === 0 ? markdown : null,\n        json: index === 0 ? jsonData : null,\n        statistics: index === 0 ? collectStatistics(reasoningData.intermediateSteps) : null\n      }\n    }\n  }));\n}\n\n// ═════════════════════════════════════════════════════════════════\n// 7. ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ\n// ═════════════════════════════════════════════════════════════════\n\nfunction escapeHtml(text) {\n  return String(text)\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n}\n\nfunction convertMarkdownToTelegramHtml(markdown) {\n  let html = markdown;\n  html = html.replace(/^## (.+)$/gm, '<b>$1</b>');\n  html = html.replace(/\\*\\*(.+?)\\*\\*/g, '<b>$1</b>');\n  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');\n  html = html.replace(/^- /gm, '  • ');\n  return html;\n}\n\nfunction splitMessageForTelegram(message, maxLength = 4096) {\n  // Updated to use Telegram's actual HTML message limit of 4096 characters\n  if (message.length <= maxLength) return [message];\n\n  const parts = [];\n  let currentPart = '';\n  const lines = message.split('\\n');\n\n  for (const line of lines) {\n    // Check if adding this line would exceed the limit\n    if ((currentPart + line + '\\n').length > maxLength) {\n      // If current part has content, push it\n      if (currentPart) parts.push(currentPart.trimEnd());\n\n      // If a single line is longer than maxLength, split it by words\n      if (line.length > maxLength) {\n        const words = line.split(' ');\n        let longLinePart = '';\n        for (const word of words) {\n          if ((longLinePart + word + ' ').length > maxLength) {\n            if (longLinePart) parts.push(longLinePart.trimEnd());\n            longLinePart = word + ' ';\n          } else {\n            longLinePart += word + ' ';\n          }\n        }\n        currentPart = longLinePart;\n      } else {\n        currentPart = line + '\\n';\n      }\n    } else {\n      currentPart += line + '\\n';\n    }\n  }\n\n  if (currentPart.trim()) parts.push(currentPart.trimEnd());\n  return parts;\n}\n\n// ═════════════════════════════════════════════════════════════════\n// ЭКСПОРТ\n// ═════════════════════════════════════════════════════════════════\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = {\n    formatReasoningAdvanced,\n    filterEmptySteps,\n    groupStepsByTool,\n    getLastSuccessfulCalls,\n    collectStatistics,\n    formatStatistics,\n    exportToMarkdown,\n    exportToJSON,\n    TOOL_EMOJIS\n  };\n}\n\n// Для использования в n8n\nif (typeof $input !== 'undefined') {\n  return mainAdvanced();\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [560, 0],
      "id": "3905f85f-5ce3-4f32-bb58-ee900f230d40",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "url": "https://api.telegram.org/botТОКЕНВАШ/sendMessage",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "chat_id",
              "value": "=371806044"
            },
            {
              "name": "text",
              "value": "={{ $json.message }}"
            },
            {
              "name": "parse_mode",
              "value": "HTML"
            }
          ]
        },
        "options": {}
      },
      "id": "9c15f4ee-2c29-41da-8b49-425846e9644c",
      "name": "HTTP Request2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [784, 0],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "endpointUrl": "https://mcp-piplines.godkod.ru/mcp",
        "include": "selected",
        "includeTools": ["vector_search"],
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [1136, 208],
      "id": "ef742721-b971-4fbe-9e1d-91a55191d837",
      "name": "vector_search"
    }
  ],
  "connections": {
    "When chat message received": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "natural_search": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "quick_calculate": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "show_rate_details": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "compare_variants": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "find_similar_rates": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "HTTP Request2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "vector_search": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {
    "When chat message received": [
      {
        "sessionId": "545a9d7d497d402aafd248913b7e1807",
        "action": "sendMessage",
        "chatInput": "Какова стоимость 1 м² кровли из металлочерепицы?"
      }
    ]
  },
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "99485cbed714598a82bf805d58b27d7e19417890b4706a5a1b013bdf1aadf053"
  }
}
